---
tags:
  - embeddedLinux
---
## Toolchain
## Toolchain
A toolchain is a set of tools that compiles source code into executables that can run on the target device. These tools include a compiler, linker, and runtime libraries. A toolchain is required to build the other three elements of embedded Linux, namely the bootloader, kernel, and root filesystem.
 
Toolchains have typically been based on components from the GNU project, and still remain the most popular, providing support for a wide range of architectures. Recently, the Clang compiler and the associated Low Level Virtual Machine (LLVM) have become a viable alternative. LLVM/Clang toolchain offers faster compilation and better diagnostics.

A standard GNU toolchain consists of three main components:
- Binutils: Set of binary utilities including the assembler and the linker.
- GNU Compiler Collection (GCC): Compilers for C and other languages. The compilers use a common back-end that produces assembler code which is fed to the GNU assembler.
- C library: A standardized API, based on the POSIX specification, that serves as the main interface to the kernel for applications.
![[Pasted image 20230926160748.png]]
- GNU Debugger: An optional part of the toolchain for debugging purposes.

Along with the toolchain, a copy of the Linux kernel headers are needed for accessing the kernel directly and to be able to compile the C library. The Linux kernel headers are backwards compatible.

### Types of Toolchains
Based on the relationship between the host and the target machines, toolchains can be thought of as being:
- Native: Wherein the toolchain runs on the same type of system (or even the same system) as the program it generates.
- Cross: Wherein the toolchain runs on a different type of system that the target.

Cross-development is the popular form since most embedded devices lack the computing, memory and storage bandwidth. On the other hand, with cross-development there is the burden of compiling all libraries and tools for the target. This is not always easy since many open source packages aren't built this way.

### CPU Architectures
Building the right toolchain also depends n the capabilities of the target CPU:
- CPU Architecture: Whether it is ARM, MIPS, x86_64, etc.
- Big or little endian operation
- Floating point support: Whether hardware floating-point unit exists or a software library is needed instead.
- Application Binary Interface (ABI): The calling convention used for passing parameters between function calls.

GNU uses a prefix to identify the various combination that can be generated for a tool. This consists of three to four labels separated by dashes:
- CPU: CPU architecture along with the endianness, if it exists. Ex: `mipsel`, `armeb`
- Vendor: Provider of the toolchain.
- Kernel
- Operating system: Name for the user space component. The ABI maybe appended here as well.

### Choosing the C Library
The C Library provides the programming interface to the kernel. It serves as the gateway for Linux programs to interact with the kernel through system calls. There are several C libraries to choose from, each with its own pros and cons. The main options are:
- glibc: Most complete implementation of POSIX; large library.
- musl libc: Small, standards-compliant library; good choice for systems with limited amount of RAM and storage.
- uClib-ng: Developed to work with uClinux(Linux for CPUs without MMU)

### Obtaining a Toolchain
There are three choices for obtaining a cross-development toolchain:
- ready-built toolchains: Typically from target device vendors, consortiums, third-party vendors, etc.
- using toolchains generated by an embedded build tool
- creating one yourself

One option for creating a toolchain by yourself is by using `crosstool-NG`. After installing crosstool, the following commands may come in handy:
- `ct-ng list-samples`: To list all samples of common use cases.
- `ct-ng show-<sample>`: Show default configuration of sample before building.
- `ct-ng menuconfig`: Configuration menu for reviewing the config and making changes.
- `ct-ng build`: Build toolchain components.
- `ct-ng distclean`: Clean any artifacts from a previous build.

### Anatomy of a Toolchain
The toolchain is built into a directory with the name of the sample. For example, `arm-cortex_a8-linux-gnueabihf`. Within this directory one can find `bin/`, which contains the cross compiler, typically named with the sample prefix. For example, for the sample mentioned earlier, it will be `arm-cortex_a8-linux-gnueabihf-gcc`.

The toolchain `sysroot` contains subdirectories for libraries, header and other configuration files. `sysroot` contains the following subdirectories:
- `lib`: Contains the shared objects for the C library and the dynamic linker/loader, `ld-linux`
- `usr/lib`: The static library archive files for the C library, and any other libraries that may be installed subsequently
- `usr/include`: Contains the headers for all the libraries
- `usr/bin`: Contains the utility programs that run on the target, such as the `ldd` command 
- `usr/share`: Used for localization and internationalization
- `sbin`: Provides the `ldconfig` utility, used to optimize library loading paths

Finally, the C library contains four main parts that together implement the POSIX API:
- `libc`: This is the main C library
- `libm`: Contains math functions
- `libpthread`: Contains all POSIX thread functions
- `librt`: Real-time extensions to POSIX

### Linking Libraries
Libraries can be linked with an application either statically during compilation or dynamically at runtime. 
#### Static Libraries
Static libraries are useful in circumstances where the system is smallâ€”only code required by the application is linked as opposed to copying the entire C library. Static linking is also useful if a program needs to run before the filesystem is available.

A library can be linked statically using the `-l` option to `gcc` or by using the `-static` option. `static` links ALL the libraries, which may lead to a large executable size.

Creating a static library called `libtest.a` from two source files `test1.c` and `test2.c` can be done like so:
```
arm-cortex_a8-linux-gnueabihf-gcc -c test1.c
arm-cortex_a8-linux-gnueabihf-gcc -c test2.c 
arm-cortex_a8-linux-gnueabihf-ar rc libtest.a test1.o test2.o
```

Linking this library can be done using:
```
arm-cortex_a8-linux-gnueabihf-gcc helloworld.c -ltest -L../libs -I../libs -o helloworld
```

#### Shared Libraries
Shared libraries can be linked at runtime. This makes them more efficient for storage, since only one copy of the code needs to be loaded. A shared library named `libtest.so` can be created like so:
```
arm-cortex_a8-linux-gnueabihf-gcc -fPIC -c test1.c
arm-cortex_a8-linux-gnueabihf-gcc -fPIC -c test2.c
arm-cortex_a8-linux-gnueabihf-gcc -shared -o libtest.so test1.o test2.o
```

Linking this library is done exactly like in the static case. However, the code is not included in the executable. Instead, there is a reference to the library that the runtime linker, `/lib/ld-linux-armhf` will resolve.
```
arm-cortex_a8-linux-gnueabihf-gcc helloworld.c -ltest -L../libs -I../libs -o helloworld
```

Each shared library has a release version and an interface number. The release version, which appears as a string appended to the library name, is the version of the library used to compile a program. The interface number encodes when the library was built and is used by the runtime linker when it loads the library. All in all, the directory of a library (here, `libjpeg`) might look like this:
- `libjpeg.a`: Library archive used for static linking.
- `libjpeg.so -> libjpeg.so.9.0.2`: Symbolic link used for dynamic linking.
- `libjpeg.so.8 -> libjpeg.so.8.2.2`: Symbolic link used for loading the library at runtime.
- `libjpeg.so.8.2.2`: Actual shared library.
- `libjpeg.so.9.0.2`: Actual shared library.

### Cross-Compiling
With the toolchain in-place as discussed in the previous sections, tools, applications, and libraries can be compiled for the target using three common build systems:
- Pure makefiles
- Autotools, the GNU build system
- CMake