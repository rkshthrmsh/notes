---
tags:
  - embeddedLinux
  - yocto
---
## Yocto: Under the Hood
Yocto is a complex project. Taking a closer look at its different parts is a good way towards understanding it.
### Workflow
Yocto's workflow is based on the OpenEmbedded project. In this workflow, source materials feed into the system as inputs by way of metadata, in the form of BitBake recipes. The build system uses this metadata to fetch, configure, and compile the source code into binary packages. These individual output packages are assembled inside a staging area before the finished Linux image and SDK are generated, complete with a manifest that includes a license for each package.

![[Pasted image 20231002155122.png]]

There are seven steps in Yocto's build system workflow:
1. Define layers for policy, machine, and software metadata.
2. Fetch sources from the source URI of a software project.
3. Extract the source code, apply any patches, and compile the software.
4. Install the build artifacts into a staging area for packaging.
5. Bundle the installed build artifacts into a package feed for the root filesystem.
6. Run QA checks on the binary package feed before submitting it.
7. Generate the finished Linux image and an SDK in parallel.

The packages generated can be in `rpm`, `deb`, or `ipk` format. In addition to the main binary package, the build system attempts to generate all of the following packages by default:
- `dbg`: Binary files, including debug symbols
- `static-dev`: Header files and static libraries
- `dev`: Header files and share library symbolic links
- `doc`: Documentation, including `man` pages
- `locale`: Language translation information

The set of packages to be generated is determined by the `PACKAGES` variable, which is present in `meta/classes/packagegroup.bbclass`.
#### Metadata
Metadata is the input that goes into the build system and controls what gets built and how. Valid metadata includes policies, BSPs, recipes, patches, and more.

The first choice a developer makes in a build project is the machine architecture to target. This is done by setting the `MACHINE` variable in the `conf/local.conf` file. Next, architecture-specific settings are defined in files called *tunes* in `meta/conf/machine/include` or the BSP layers (many of which are included with every Yocto release).

Metadata needs source code to act upon. BitBake's `do_fetch` task can obtain recipe source files in many ways, with two prominent ones being:
- Downloading a tar ball of a project.
- Forking a project repository on GitHub.
#### Build Tasks
After `do_fetch`, the next steps in the recipe are: `do_patch`, `do_configure`, `do_compile`, `do_install`, `do_package`, `do_package_data`, `do_package_qa`, and `do_package_write_*`.

![[Pasted image 20231002161909.png]]

- `do_patch` uses the `FILESPATH` variable and a recipe's `SRC_URI` variable to locate patch files and apply them to the intended source code. The default `FILESPATH` variable (and consequently the default set of directories) are defined in `meta/classes/base.bbclass`. By convention, pathc files have the `.diff` or `.patch` extension and reside in a subdirectory below where the corresponding recipe files is located.
- After patching, the `do_configure` and `do_compile` tasks configure, compile, and link the recipe.
- The resulting files at the end of the `do_compile` task are copied onto the staging area by the `do_install` task.
- In the staging area, the `do_package` and `do_package_data` tasks, together, process the build artifacts and divide them up into packages.
- Before these packages are submitted to the package feed, the `do_package_qa` task runs a battery of autogenerated QA checks, which are defined in `meta/classes/insane.class`
- Finally, the `do_package_write_*` tasks create the individual packages and send them to the package feeds area.

At this stage, BitBake is ready for image and SDK generation.
#### Image Generation
Generating an image is a multi-stage process which is carried out by the `do_rootfs` task based on the following variables:
- `IMAGE_INSTALL`: Packages to install onto the image
- `PACKAGE_EXCLUDE`: Packages to exclude from the image
- `IMAGE_FEATRES`: Additional packages to install onto the image
- `PACKAGE_CLASSES`: Package format to use (`rpm`, `deb`, or `ipk`)
- `IMAGE_LINGUAS`: Languages to include support for

The list of packages from the `IMAGE_INSTALL` variable is passed to a package manager so that the packages are installed on the image. The packages are installed regardless of whether a runtime package manager is included on the target. In case there is no runtime package manager, then inessential files get deleted at the end of this phase.

After package installation is complete, the package's post-installation scripts are run. If all post-installation scripts are run successfully, a top-level `.manifest` is written to, to maintain a list of all packages installed on the image. Finally, optimizations are performed on the root filesystem image.

Next, the `do_image` task begins image processing. First, all the pre-processing commands defined by the `IMAGE_PREPROCESS_COMMAND` variable get executed. Then, the process creates the final image output files. It does this by launching a `do_image_*` task for every image type (for example, `cpio.lz4`, `ext4`, and `squashfs-lzo`) specified in the `IMAGE_FSTYPES` variable. The build system then takes the contents of the `IMAGE_ROOTFS` directory and converts it into one or more image files. These output image files are compressed when the specified filesystem format allows for it. Lastly, the `do_image_complete` task finishes the image by executing every post-processing command defined by the `IMAGE_POSTPROCESS_COMMAND` variable.
### Separating Metadata into Layers
Yocto metadata is organized around the following concepts which map directly to the actual byproducts of the build system.
- **distr**: OS features including the choice of C library, `init` system, and the window manager.
- **machine**: CPU architecture, kernels, drivers, and bootloader
- **recipe**: Application binaries and/or scripts
- **image**: Development, manufacturing, or production

In order to have the project be flexible and maintainable, it is necessary to create at least individual distro, BSP, and application layers.
- distro layer: Frame buffer and window manager configuration files
- BSP layer: Specifies bootloader, kernel, and device tree for the target hardware
- Application layer: Recipes needed to build all the packages for the custom application

With the addition of multiple layers, it becomes difficult to locate recipe files. Fortunately, Yocto provides command-line tools like `recipetool`, `oe-pkgdata-util`, and `oe-pkgdata-browser` to help.
## [[BitBake]]